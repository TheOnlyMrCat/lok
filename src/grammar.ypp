%code top {
#include "clok.hpp"

extern int yylex();
void yyerror(const char *p);
}

%code requires {
typedef size_t strings_t;
struct Node;
}

%union {
  long long valI;
  double valF;
  strings_t valC;
  Node *valN;
}

%locations

%code provides {

/* Currently, these are in no particular order.
 * When released, the order will be normalised.
 */

enum NodeType {
	NONE,
	LOAD,
	RUN,
	FUNCDEF,
	BLOCK,
	TYPESINGLE,
	TYPEMULTI,
	TYPEFN,
	PARAMLIST,
	PARAM,
	DECL,
	LIBNAME,
	FILEPATH,
	QUALID,
	QUALIDOP,
	QUALPART,
	EXPRASSIG,
	EXPRBASIC,
	EXPRDECL,
	VALINT,
	VALFLOAT,
	VALSTR
};

union ValueType {
	long long valI;
	double valF;
	strings_t valC;
};

struct Node {
	Node(int type, int children) : type(type), children(std::vector<std::unique_ptr<Node>>(children)) {}

	int type;
	union ValueType value;
  YYLTYPE location;

	std::vector<std::unique_ptr<Node>> children;
};
}

%define parse.error verbose
%define parse.lac full

%token <valC> ID STRING
%token <valF> FLOAT
%token <valI> INTEGER CHAR

%token DBLCOLON "::" DBLBAR "||" DBLAND "&&" DBLXOR "^^" DBLLEFT "<<" DBLRIGHT ">>" TPLRIGHT ">>>" DBLPLUS "++" DBLMINUS "--" DBLNOT "!!"
%token DBLEQ "==" NOTEQ "!=" GTEQ ">=" LTEQ "<="
%token RSARROW "->" RDARROW "=>" RRDARROW ">=>" RUNK "run" LOADK "load"
%token COMPADD "+=" COMPSUB "-=" COMPMUL "*=" COMPDIV "/=" COMPMOD "%=" COMPAND "&=" COMPIOR "|=" COMPXOR "^=" COMPASL "<<=" COMPASR ">>=" COMPUSR ">>>="

%type <valC> LibraryName BinaryOperator PrefixOperator PostfixOperator ArithmeticOperator LogicalOperator ComparisonOperator CompAssignOperator
%type <valN> LoadExpression FileLocator FilePath NamespaceItem RunDeclaration
%type <valN> BasicDeclaration FuncDefinition FunctionBody ParameterList Parameters Parameter
%type <valN> Type SingleType TupleTypes TupleType FunctionType
%type <valN> BlockStatement Statements Statement
%type <valN> Expression AssignExpression BasicExpression
%type <valN> QualifiedID QualifiedIDPart QualifiedIDWithOperators TypeName BasicValue BasicValueString

%left "||"
%left "^^"
%left "&&"
%left '|'
%left '^'
%left '&'
%left "==" "!="
%left '<' "<=" '>' ">="
%left "<=>"
%left "<<" ">>" ">>>"
%left '+' '-'
%left '*' '/' '%'

%left "PostfixOperator"
%right "PrefixOperator"

%code {
  Node *addChild(Node *parent, Node *child) {
    parent->children.emplace_back(child);
    return child;
  }
}

%%
top:
    %empty
  | top LoadExpression { parseResult->children.emplace_back($2); }
  | top NamespaceItem  { parseResult->children.emplace_back($2); }
  ;

LoadExpression:
    "load" '(' FileLocator ')' { $$ = new Node(1, LOAD); addChild($$, $3); }
  ;

FileLocator:
    FilePath                 { $$ = new Node(1, NONE); addChild($$, $1); }
  | LibraryName ':' FilePath { $$ = new Node(2, NONE); addChild($$, new Node(0, LIBNAME))->value.valC = $1; addChild($$, $3); }
  ;

FilePath:
    ID              { $$ = new Node(0, FILEPATH); $$->value.valC = $1; }
  | ID '/' FilePath { $$ = new Node(1, FILEPATH); addChild($$, $3); $$->value.valC = $1; }
  ;

LibraryName:
    ID
  ;

NamespaceItem:
    BasicDeclaration
  | RunDeclaration
  ;

BasicDeclaration:
    ID ':' Type '=' Expression ';' { $$ = new Node(2, DECL); $$->value.valC = $1; addChild($$, $3); addChild($$, $5); }
  | ID ':' '=' Expression ';'      { $$ = new Node(2, DECL); $$->value.valC = $1; addChild($$, $4); }
  | ID ':' Type ';'                { $$ = new Node(1, DECL); $$->value.valC = $1; addChild($$, $3); }
  ;

RunDeclaration:
    "run" FuncDefinition         { $$ = new Node(1, RUN); addChild($$, $2); $$->value.valI = -1; }
  | "run" INTEGER FuncDefinition { $$ = new Node(1, RUN); addChild($$, $3); $$->value.valI = $2; }
  ;

FuncDefinition:
    Parameters "->" Type "=>" Expression    { $$ = new Node(3, FUNCDEF); addChild($$, $5); addChild($$, $1); addChild($$, $3); }
  | Parameters "=>" Expression              { $$ = new Node(2, FUNCDEF); addChild($$, $3); addChild($$, $1); }
  | Parameters "->" Type ">=>" FunctionBody { $$ = new Node(3, FUNCDEF); addChild($$, $5); addChild($$, $1); addChild($$, $3); }
  | Parameters ">=>" FunctionBody           { $$ = new Node(2, FUNCDEF); addChild($$, $3); addChild($$, $1); }
  ;

FunctionBody:
    BlockStatement
  ;

Parameters:
    '(' ')'               { $$ = new Node(0, PARAMLIST); }
  | '(' ParameterList ')' { $$ = $2; }
  ;

ParameterList:
    Parameter                   { $$ = new Node(1, PARAMLIST); addChild($$, $1); }
  | ParameterList ',' Parameter { $$ = $1; addChild($$, $3); }
  ;

Parameter:
    ID          { $$ = new Node(0, PARAM); $$->value.valC = $1; }
  | ID ':' Type { $$ = new Node(1, PARAM); $$->value.valC = $1; addChild($$, $3); }
  ;

TypeName:
    QualifiedID
  ;

Type:
    SingleType
  | TupleType
  | FunctionType
  ;

SingleType:
    TypeName { $$ = new Node(1, TYPESINGLE); addChild($$, $1); }
  ;

TupleType:
    '(' TupleTypes ')' { $$ = $2; }
  ;

TupleTypes:
    Type                { $$ = new Node(1, TYPEMULTI); addChild($$, $1); }
  | TupleTypes ',' Type { $$ = $1; addChild($$, $3); }
  ;

FunctionType:
    TupleType "->" Type { $$ = new Node(2, TYPEFN); addChild($$, $1); addChild($$, $3); }
  ;

BlockStatement:
    '{' '}'            { $$ = new Node(0, BLOCK); }
  | '{' Statements '}' { $$ = $2; }
  ;

Statements:
    Statement            { $$ = new Node(1, BLOCK); addChild($$, $1); }
  | Statements Statement { $$ = $1; addChild($$, $2); }
  ;

Statement:
    Expression ';'
  | BasicDeclaration
  | BlockStatement
  ;

QualifiedID:
    QualifiedIDPart                 { $$ = new Node(1, QUALID); addChild($$, $1); }
  | LibraryName ':' QualifiedIDPart { $$ = new Node(2, QUALID); addChild($$, $3); addChild($$, new Node(0, LIBNAME))->value.valC = $1; }
  ;

QualifiedIDPart:
    ID                     { $$ = new Node(0, QUALPART); $$->value.valC = $1; }
  | ID '.' QualifiedIDPart { $$ = new Node(1, QUALPART); $$->value.valC = $1; addChild($$, $3); }
  ;

QualifiedIDWithOperators:
    QualifiedID                              { $$ = new Node(1, QUALIDOP); addChild($$, $1); }
  | PrefixOperator QualifiedIDWithOperators  { $$ = new Node(2, QUALIDOP); addChild($$, new Node(0, NONE))->value.valC = $1; addChild($$, $2); }
  | QualifiedIDWithOperators PostfixOperator { $$ = new Node(2, QUALIDOP); addChild($$, $1); addChild($$, new Node(0, NONE))->value.valC = $2; }
  ;

Expression:
    AssignExpression
  | BasicExpression
  ;

AssignExpression:
    QualifiedID '=' Expression                { $$ = new Node(2, EXPRASSIG); addChild($$, $1); addChild($$, $3); $$->value.valC = getString(""); }
  | QualifiedID CompAssignOperator Expression { $$ = new Node(2, EXPRASSIG); addChild($$, $1); addChild($$, $3); $$->value.valC = $2; }
  ;

BasicExpression:
    BasicValue                                        { $$ = $1; }
  | BasicExpression BinaryOperator BasicExpression    { $$ = new Node(2, EXPRBASIC); addChild($$, $1); $$->value.valC = $2; addChild($$, $3); }
  | '(' Expression ')'                                { $$ = $2; }
  | '(' Expression ')' BinaryOperator BasicExpression { $$ = new Node(2, EXPRBASIC); addChild($$, $2); $$->value.valC = $4; addChild($$, $5); }
  ;

BasicValue:
    QualifiedIDWithOperators { $$ = $1; }
  | FuncDefinition           { $$ = $1; }
  | BasicValueString         { $$ = $1; }
  | INTEGER                  { $$ = new Node(0, VALINT); $$->value.valI = $1; }
  | FLOAT                    { $$ = new Node(0, VALFLOAT); $$->value.valF = $1; }
  | CHAR                     { $$ = new Node(0, VALINT); $$->value.valC = $1; }
  ;

BasicValueString:
    STRING { $$ = new Node(0, VALSTR); $$->value.valC = $1; }
  ;

BinaryOperator:
    ArithmeticOperator
  | LogicalOperator
  | ComparisonOperator
  ;

ArithmeticOperator:
    '+'   { $$ = getString("+"); }
  | '*'   { $$ = getString("*"); }
  | '-'   { $$ = getString("-"); }
  | '/'   { $$ = getString("/"); }
  | '%'   { $$ = getString("%"); }
  | '&'   { $$ = getString("&"); }
  | '|'   { $$ = getString("|"); }
  | '^'   { $$ = getString("^"); }
  | "<<"  { $$ = getString("<<"); }
  | ">>"  { $$ = getString(">>"); }
  | ">>>" { $$ = getString(">>>"); }
  ;

LogicalOperator:
    "&&"  { $$ = getString("&&"); }
  | "||"  { $$ = getString("||"); }
  | "^^"  { $$ = getString("^^"); }
  ;

ComparisonOperator:
    "=="  { $$ = getString("=="); }
  | "!="  { $$ = getString("!="); }
  | '<'   { $$ = getString("<"); }
  | '>'   { $$ = getString(">"); }
  | "<="  { $$ = getString("<="); }
  | ">="  { $$ = getString(">="); }
  | "<=>" { $$ = getString("<=>"); }
  ;

PrefixOperator:
    '+'  { $$ = getString("+"); }
  | '-'  { $$ = getString("-"); }
  | '*'  { $$ = getString("*"); }
  | '&'  { $$ = getString("&"); }
  | "++" { $$ = getString("++"); }
  | "--" { $$ = getString("--"); }
  | '!'  { $$ = getString("!"); }
  | "!!" { $$ = getString("!!"); }
  ;

PostfixOperator:
    "++" { $$ = getString("++"); }
  | "--" { $$ = getString("--"); }
  ;

CompAssignOperator:
    "+="   { $$ = getString("+"); }
  | "-="   { $$ = getString("-"); }
  | "*="   { $$ = getString("*"); }
  | "/="   { $$ = getString("/"); }
  | "%="   { $$ = getString("%"); }
  | "&="   { $$ = getString("&"); }
  | "|="   { $$ = getString("|"); }
  | "^="   { $$ = getString("^"); }
  | "<<="  { $$ = getString("<<"); }
  | ">>="  { $$ = getString(">>"); }
  | ">>>=" { $$ = getString(">>>"); }
  ;

%%

extern std::string filename;

void yyerror(const char *p) {
    PLOGE << filename << ':' << yylloc.first_line << '.' << yylloc.first_column << ": " << p;
}