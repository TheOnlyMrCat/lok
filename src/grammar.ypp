%code top {
#include "clok.hpp"
#include "bridge.hpp"

extern int yylex();
void yyerror(const char *p);
}

%require "3.5"
%language "c++"
%skeleton "lalr1.cc"

%define api.value.type variant
%define api.token.constructor

%locations

%code requires {
class Bridge;

struct Node;
typedef std::unique_ptr<Node> NodePtr;
typedef size_t strings_t;
}

%param { Bridge& bridge }

%code provides {

/* Currently, these are in no particular order.
 * When released, the order will be normalised.
 */

enum class NodeType {
#include "nodetypenames.txt"
};

union ValueType {
	long long valI;
	double valF;
	strings_t valC;
};

struct Node {
	Node(int initialChildren, NodeType type, yy::parser::location_type loc) : type(type), location(loc) {
    children.reserve(initialChildren);
  }

	NodeType type;
	union ValueType value;
  yy::parser::location_type location;

	std::vector<std::unique_ptr<Node>> children;
};
}

%define parse.error verbose
%define parse.lac full

%code {
#include "bridge.hpp"
}

%token <strings_t> ID STRING
%token <double> FLOAT
%token <long long> INTEGER CHAR

%token DBLCOLON "::" DBLBAR "||" DBLAND "&&" DBLXOR "^^" DBLLEFT "<<" DBLRIGHT ">>" TPLRIGHT ">>>" DBLPLUS "++" DBLMINUS "--" DBLNOT "!!"
%token DBLEQ "==" NOTEQ "!=" GTEQ ">=" LTEQ "<="
%token RSARROW "->" RDARROW "=>" RRDARROW ">=>"
%token COMPADD "+=" COMPSUB "-=" COMPMUL "*=" COMPDIV "/=" COMPMOD "%=" COMPAND "&=" COMPIOR "|=" COMPXOR "^=" COMPASL "<<=" COMPASR ">>=" COMPUSR ">>>="
%token END 0

%token RUNK "run" LOADK "load" IFK "if" ELSEK "else" FORK "for"

%type <strings_t> LibraryName BinaryOperator PrefixOperator PostfixOperator ArithmeticOperator LogicalOperator ComparisonOperator CompAssignOperator
%type <NodePtr> LoadStatement FileLocator FilePath NamespaceItem RunDeclaration
%type <NodePtr> BasicDeclaration FuncDefinition FunctionBody ParameterList Parameters Parameter
%type <NodePtr> Type SingleType TupleTypes TupleType FunctionType
%type <NodePtr> BlockStatement Statements Statement
%type <NodePtr> IfStatement ForStatement
%type <NodePtr> Expression AssignExpression BasicExpression Expressions
%type <NodePtr> QualifiedID QualifiedIDPart QualifiedIDWithOperators TypeName BasicValue BasicValueString FunctionCall

%left "||"
%left "^^"
%left "&&"
%left '|'
%left '^'
%left '&'
%left "==" "!="
%left '<' "<=" '>' ">="
%left "<=>"
%left "<<" ">>" ">>>"
%left '+' '-'
%left '*' '/' '%'

%left "PostfixOperator"
%right "PrefixOperator"

%code {
  inline void addChild(NodePtr& parent, NodePtr&& child) {
    parent->children.emplace_back(std::move(child));
  }

  inline void addChild(NodePtr& parent, NodePtr& child) {
    parent->children.emplace_back(std::move(child));
  }
}

%%
root:
    %empty
  | root LoadStatement { addChild(parseResult, $2); }
  | root NamespaceItem { addChild(parseResult, $2); }
  ;

LoadStatement:
    "load" '(' FileLocator ')' { $$ = std::make_unique<Node>(1, NodeType::LOAD, @$); addChild($$, $3); }
  ;

FileLocator:
    FilePath                 { $$ = std::make_unique<Node>(1, NodeType::NONE, @$); addChild($$, $1); }
  | LibraryName ':' FilePath { $$ = std::make_unique<Node>(2, NodeType::NONE, @$); NodePtr libN = std::make_unique<Node>(0, NodeType::LIBNAME, @$); libN->value.valC = $1; addChild($$, libN); addChild($$, $3); }
  ;

FilePath:
    ID              { $$ = std::make_unique<Node>(0, NodeType::FILEPATH, @$); $$->value.valC = $1; }
  | ID '/' FilePath { $$ = std::make_unique<Node>(1, NodeType::FILEPATH, @$); addChild($$, $3); $$->value.valC = $1; }
  ;

LibraryName:
    ID
  ;

NamespaceItem:
    BasicDeclaration { $$ = std::move($1); }
  | RunDeclaration   { $$ = std::move($1); }
  ;

BasicDeclaration:
    ID ':' Type '=' Expression ';' { $$ = std::make_unique<Node>(2, NodeType::DECL, @$); $$->value.valC = $1; addChild($$, $3); addChild($$, $5); }
  | ID ':' '=' Expression ';'      { $$ = std::make_unique<Node>(2, NodeType::DECL, @$); $$->value.valC = $1; addChild($$, $4); }
  | ID ':' Type ';'                { $$ = std::make_unique<Node>(1, NodeType::DECL, @$); $$->value.valC = $1; addChild($$, $3); }
  ;

RunDeclaration:
    "run" FuncDefinition         { $$ = std::make_unique<Node>(1, NodeType::RUN, @$); addChild($$, $2); $$->value.valI = -1; }
  | "run" INTEGER FuncDefinition { $$ = std::make_unique<Node>(1, NodeType::RUN, @$); addChild($$, $3); $$->value.valI = $2; }
  ;

FuncDefinition:
    Parameters "->" Type "=>" Expression    { $$ = std::make_unique<Node>(3, NodeType::FUNCDEF, @$); addChild($$, $5); addChild($$, $1); addChild($$, $3); }
  | Parameters "=>" Expression              { $$ = std::make_unique<Node>(2, NodeType::FUNCDEF, @$); addChild($$, $3); addChild($$, $1); }
  | Parameters "->" Type ">=>" FunctionBody { $$ = std::make_unique<Node>(3, NodeType::FUNCDEF, @$); addChild($$, $5); addChild($$, $1); addChild($$, $3); }
  | Parameters ">=>" FunctionBody           { $$ = std::make_unique<Node>(2, NodeType::FUNCDEF, @$); addChild($$, $3); addChild($$, $1); }
  ;

FunctionBody:
    BlockStatement { $$ = std::move($1); }
  ;

Parameters:
    '(' ')'               { $$ = std::make_unique<Node>(0, NodeType::PARAMLIST, @$); }
  | '(' ParameterList ')' { $$ = std::move($2); }
  ;

ParameterList:
    Parameter                   { $$ = std::make_unique<Node>(1, NodeType::PARAMLIST, @$); addChild($$, $1); }
  | ParameterList ',' Parameter { $$ = std::move($1); addChild($$, $3); }
  ;

Parameter:
    ID          { $$ = std::make_unique<Node>(0, NodeType::PARAM, @$); $$->value.valC = $1; }
  | ID ':' Type { $$ = std::make_unique<Node>(1, NodeType::PARAM, @$); $$->value.valC = $1; addChild($$, $3); }
  ;

TypeName:
    QualifiedID { $$ = std::move($1); }
  ;

Type:
    SingleType   { $$ = std::move($1); }
  | TupleType    { $$ = std::move($1); }
  | FunctionType { $$ = std::move($1); }
  ;

SingleType:
    TypeName { $$ = std::make_unique<Node>(1, NodeType::TYPESINGLE, @$); addChild($$, $1); }
  ;

TupleType:
    '(' TupleTypes ')' { $$ = std::move($2); }
  ;

TupleTypes:
    Type                { $$ = std::make_unique<Node>(1, NodeType::TYPEMULTI, @$); addChild($$, $1); }
  | TupleTypes ',' Type { $$ = std::move($1); addChild($$, $3); }
  ;

FunctionType:
    TupleType "->" Type { $$ = std::make_unique<Node>(2, NodeType::TYPEFN, @$); addChild($$, $1); addChild($$, $3); }
  ;

BlockStatement:
    '{' '}'            { $$ = std::make_unique<Node>(0, NodeType::BLOCK, @$); }
  | '{' Statements '}' { $$ = std::move($2); }
  ;

Statements:
    Statement            { $$ = std::make_unique<Node>(1, NodeType::BLOCK, @$); addChild($$, $1); }
  | Statements Statement { $$ = std::move($1); addChild($$, $2); }
  ;

Statement:
    Expression ';'   { $$ = std::move($1); }
  | BasicDeclaration { $$ = std::move($1); }
  | BlockStatement   { $$ = std::move($1); }
  | IfStatement      { $$ = std::move($1); }
  | ForStatement     { $$ = std::move($1); }
  ;

IfStatement:
    "if" '(' Expression ')' Statement                  { $$ = std::make_unique<Node>(2, NodeType::STMTIF, @$); addChild($$, $3); addChild($$, $5); /* TODO: Basic expression maybe? */ }
  | "if" '(' Expression ')' Statement "else" Statement { $$ = std::make_unique<Node>(3, NodeType::STMTIF, @$); addChild($$, $3); addChild($$, $5); addChild($$, $7);}
  ;

ForStatement:
    "for" '(' BasicDeclaration BasicExpression ';' Expression ')' Statement { $$ = std::make_unique<Node>(4, NodeType::STMTFOR, @$); addChild($$, $3); addChild($$, $4); addChild($$, $6); addChild($$, $8); }

QualifiedID:
    QualifiedIDPart                 { $$ = std::make_unique<Node>(1, NodeType::QUALID, @$); addChild($$, $1); }
  | LibraryName ':' QualifiedIDPart { $$ = std::make_unique<Node>(2, NodeType::QUALID, @$); addChild($$, $3); NodePtr libN = std::make_unique<Node>(0, NodeType::LIBNAME, @$); libN->value.valC = $1; addChild($$, libN); }
  ;

QualifiedIDPart:
    ID                     { $$ = std::make_unique<Node>(0, NodeType::QUALPART, @$); $$->value.valC = $1; }
  | ID '.' QualifiedIDPart { $$ = std::make_unique<Node>(1, NodeType::QUALPART, @$); $$->value.valC = $1; addChild($$, $3); }
  ;

QualifiedIDWithOperators:
    QualifiedID                              { $$ = std::make_unique<Node>(1, NodeType::QUALIDOP, @$); addChild($$, $1); }
  | PrefixOperator QualifiedIDWithOperators  { $$ = std::make_unique<Node>(2, NodeType::QUALIDOP, @$); NodePtr op = std::make_unique<Node>(0, NodeType::NONE, @$); op->value.valC = $1; addChild($$, op); addChild($$, $2); }
  | QualifiedIDWithOperators PostfixOperator { $$ = std::make_unique<Node>(2, NodeType::QUALIDOP, @$); addChild($$, $1); NodePtr op = std::make_unique<Node>(0, NodeType::NONE, @$); op->value.valC = $2; addChild($$, op); }
  ;

Expressions:
    Expression                 { $$ = std::make_unique<Node>(1, NodeType::EXPRMULTI, @$); addChild($$, $1); }
  | Expressions ',' Expression { $$ = std::move($1); addChild($$, $3); }
  ;

Expression:
    AssignExpression { $$ = std::move($1); }
  | BasicExpression  { $$ = std::move($1); }
  ;

AssignExpression:
    QualifiedID '=' Expression                { $$ = std::make_unique<Node>(2, NodeType::EXPRASSIG, @$); addChild($$, $1); addChild($$, $3); $$->value.valC = getString(""); }
  | QualifiedID CompAssignOperator Expression { $$ = std::make_unique<Node>(2, NodeType::EXPRASSIG, @$); addChild($$, $1); addChild($$, $3); $$->value.valC = $2; }
  ;

BasicExpression:
    BasicValue                                        { $$ = std::move($1); }
  | '(' Expression ')'                                { $$ = std::move($2); }
  | BasicExpression BinaryOperator BasicExpression    { $$ = std::make_unique<Node>(2, NodeType::EXPRBASIC, @$); addChild($$, $1); $$->value.valC = $2; addChild($$, $3); }
  ;

FunctionCall:
    QualifiedIDWithOperators '(' Expressions ')' { $$ = std::make_unique<Node>(2, NodeType::FUNCCALL, @$); addChild($$, $1); addChild($$, $3); }
  ;

BasicValue:
    QualifiedIDWithOperators { $$ = std::move($1); }
  | FunctionCall             { $$ = std::move($1); }
  | FuncDefinition           { $$ = std::move($1); }
  | BasicValueString         { $$ = std::move($1); }
  | INTEGER                  { $$ = std::make_unique<Node>(0, NodeType::VALINT, @$); $$->value.valI = $1; }
  | FLOAT                    { $$ = std::make_unique<Node>(0, NodeType::VALFLOAT, @$); $$->value.valF = $1; }
  | CHAR                     { $$ = std::make_unique<Node>(0, NodeType::VALINT, @$); $$->value.valC = $1; }
  ;

BasicValueString:
    STRING { $$ = std::make_unique<Node>(0, NodeType::VALSTR, @$); $$->value.valC = $1; }
  ;

BinaryOperator:
    ArithmeticOperator
  | LogicalOperator
  | ComparisonOperator
  ;

ArithmeticOperator:
    '+'   { $$ = getString("+"); }
  | '*'   { $$ = getString("*"); }
  | '-'   { $$ = getString("-"); }
  | '/'   { $$ = getString("/"); }
  | '%'   { $$ = getString("%"); }
  | '&'   { $$ = getString("&"); }
  | '|'   { $$ = getString("|"); }
  | '^'   { $$ = getString("^"); }
  | "<<"  { $$ = getString("<<"); }
  | ">>"  { $$ = getString(">>"); }
  | ">>>" { $$ = getString(">>>"); }
  ;

LogicalOperator:
    "&&"  { $$ = getString("&&"); }
  | "||"  { $$ = getString("||"); }
  | "^^"  { $$ = getString("^^"); }
  ;

ComparisonOperator:
    "=="  { $$ = getString("=="); }
  | "!="  { $$ = getString("!="); }
  | '<'   { $$ = getString("<"); }
  | '>'   { $$ = getString(">"); }
  | "<="  { $$ = getString("<="); }
  | ">="  { $$ = getString(">="); }
  | "<=>" { $$ = getString("<=>"); }
  ;

PrefixOperator:
    '+'  { $$ = getString("+"); }
  | '-'  { $$ = getString("-"); }
  | '*'  { $$ = getString("*"); }
  | '&'  { $$ = getString("&"); }
  | "++" { $$ = getString("++"); }
  | "--" { $$ = getString("--"); }
  | '!'  { $$ = getString("!"); }
  | "!!" { $$ = getString("!!"); }
  ;

PostfixOperator:
    "++" { $$ = getString("++"); }
  | "--" { $$ = getString("--"); }
  ;

CompAssignOperator:
    "+="   { $$ = getString("+"); }
  | "-="   { $$ = getString("-"); }
  | "*="   { $$ = getString("*"); }
  | "/="   { $$ = getString("/"); }
  | "%="   { $$ = getString("%"); }
  | "&="   { $$ = getString("&"); }
  | "|="   { $$ = getString("|"); }
  | "^="   { $$ = getString("^"); }
  | "<<="  { $$ = getString("<<"); }
  | ">>="  { $$ = getString(">>"); }
  | ">>>=" { $$ = getString(">>>"); }
  ;

%%

void yy::parser::error(const location_type& l, const std::string& p) {
    PLOGE << *l.begin.filename << ':' << l.begin.line << '.' << l.begin.column << ": " << p;
}